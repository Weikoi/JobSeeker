### MySQL

参考《高性能 MySQL》 重点是 一、五、六章节

#### 关于数据库的连接操作？

left join 会保留左表的所有数据

right join 会保留右表的所有数据

inner join 只保留两个表中公共部分的信息

outer join 保留两个表的所有信息

cross join 叉连接，即笛卡尔积的形式


#### 关系型数据库的设计范式

第一范式：列原子化，不可拆分。

第二范式：不存在非主属性对主属性的部分依赖，也就是说非主属性不能只依赖于复合主键的一部分。

第三范式：消除非主属性之间的传递依赖。

BC范式：主属性内部不可有传递依赖。

第四范式：非主属性不可存在多值情形。


一般数据库设计只用到第三范式，或者3.5范式，再往后，查询效率太低。
设计数据库，遵循的范式越高，数据冗余越低，但是查询效率下降。


#### MySQL的两种常见存储引擎MyISAM和InnoDB的比较？

更加详细的内容可参考《高性能mySQL》1.5 存储引擎章节

在MySQL5.1及之前的版本，MyISAM是默认的存储引擎。它有以下特点：

    MyISAM不支持事务和行级锁，而且有一个毫无疑问的缺陷就是 崩溃后无法安全恢复。

    MyISAM对整张表加锁，而不是针对行。
    
    创建MyISAM表的时候，如果指定了DELAY_KEY_WRITE选项，
    
    在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而 是会写到内存中的键缓冲区（in-memory key buffer），只有在清理 键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。这种 方式可以极大地提升写入性能，但是在数据库或者主机崩溃时会造 成索引损坏，需要执行修复操作。

InnoDB是MySQL 5.1版本之后的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事 务大部分情况是正常提交的，很少会被回滚。InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。

    InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REPEATABLE InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级 READ（可重复读），并且通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁 定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。
    
    InnoDB表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。
    
    InnoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索 引（adaptive hash index），以及能够加速插入操作的插入缓冲区（insert buffer）等。
    
    支持事务，支持崩溃恢复，默认使用行级锁，所以支持更高的并发（也支持表级锁）。
    

#### 关于MySQL中的锁机制？
参考https://blog.csdn.net/qq_34337272/article/details/80611486

《高性能mySQL》1.2 并发控制

在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决 问题。这两种类型的锁通常被称为共享锁（shared lock)和排它锁（exclusive lock），分别也叫读锁（read lock）和写锁（write lock）。

读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个 lock）和排他锁资源，而互不干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的 写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定的 时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同 一资源。

一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只 对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定 的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。
问题是加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁
是否已经解除、释放锁等，都会增加系统的开销。如果系统花费大量的 时间来管理锁，而不是存取数据，那么系统的性能可能会因此受到影 响。
所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这
种平衡当然也会影响到性能。而MySQL则提供了多种选择。每种MySQL存储引擎都可以实现自
己的锁策略和锁粒度。

表锁是MySQL中最基本的锁策略，并且是开销最小的策略。一个用户在对 表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞 其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才 能获得读锁，读锁之间是不相互阻塞的。

行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开
销）。众所周知，在InnoDB和XtraDB，以及其他一些存储引擎中实现 了行级锁。



    

