### MySQL

参考《高性能 MySQL》 重点是 一、五、六章节

#### 关于数据库的连接操作？

left join 会保留左表的所有数据

right join 会保留右表的所有数据

inner join 只保留两个表中公共部分的信息

outer join 保留两个表的所有信息

cross join 叉连接，即笛卡尔积的形式


#### 关系型数据库的设计范式

第一范式：列原子化，不可拆分。

第二范式：不存在非主属性对主属性的部分依赖，也就是说非主属性不能只依赖于复合主键的一部分。

第三范式：消除非主属性之间的传递依赖。

BC范式：主属性内部不可有传递依赖。

第四范式：非主属性不可存在多值情形。


一般数据库设计只用到第三范式，或者3.5范式，再往后，查询效率太低。
设计数据库，遵循的范式越高，数据冗余越低，但是查询效率下降。


#### MySQL的两种常见存储引擎MyISAM和InnoDB的比较？

更加详细的内容可参考《高性能mySQL》1.5 存储引擎章节

在MySQL5.1及之前的版本，MyISAM是默认的存储引擎。它有以下特点：

    MyISAM不支持事务和行级锁，而且有一个毫无疑问的缺陷就是崩溃后无法安全恢复。

    MyISAM对整张表加锁，而不是针对行。
    
    创建MyISAM表的时候，如果指定了DELAY_KEY_WRITE选项，
    
    在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区（in-memory key buffer），只有在清理 键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。这种 方式可以极大地提升写入性能，但是在数据库或者主机崩溃时会造 成索引损坏，需要执行修复操作。

InnoDB是MySQL 5.1版本之后的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事 务大部分情况是正常提交的，很少会被回滚。InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。

    InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。其默认级别是REPEATABLE InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级 READ（可重复读），并且通过间隙锁（next-key locking）策略防止幻读的出现。间隙锁使得InnoDB不仅仅锁 定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。
    
    InnoDB表是基于聚簇索引建立的，聚簇索引对主键查询有很高的性能。
    
    InnoDB内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建hash索引以加速读操作的自适应哈希索 引（adaptive hash index），以及能够加速插入操作的插入缓冲区（insert buffer）等。
    
    支持事务，支持崩溃恢复，默认使用行级锁，所以支持更高的并发（也支持表级锁）。
    

#### 关于MySQL中的锁机制？
参考https://blog.csdn.net/qq_34337272/article/details/80611486

《高性能mySQL》1.2 并发控制

在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁（shared lock)和排它锁（exclusive lock），分别也叫读锁（read lock）和写锁（write lock）。

读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个 lock）和排他锁资源，而互不干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的 写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同 一资源。

一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只 对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。
问题是加锁也需要消耗资源。锁的各种操作，包括获得锁、检查锁
是否已经解除、释放锁等，都会增加系统的开销。如果系统花费大量的 时间来管理锁，而不是存取数据，那么系统的性能可能会因此受到影 响。
所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡，这
种平衡当然也会影响到性能。而MySQL则提供了多种选择。每种MySQL存储引擎都可以实现自
己的锁策略和锁粒度。

表锁是MySQL中最基本的锁策略，并且是开销最小的策略。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。

行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。众所周知，在InnoDB和XtraDB，以及其他一些存储引擎中实现了行级锁。


#### 理解ACID概念？

ACID表示原子性（atomicity）、一致性（consistency）、隔离性 （isolation）和持久性（durability）。一个运行良好的事务处理系统， 必须具备这些标准特征。

1. 原子性（atomicity） 一个事务必须被视为一个不可分割的最小工作单元，整个事务
中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事 务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

2. 一致性（consistency） 数据库总是从一个一致性的状态转换到另外一个一致性的状
态。在前面的例子中，一致性确保了，即使在执行第三、四条语句 之间时系统崩溃，支票账户中也不会损失200美元，因为事务最终 没有提交，所以事务中所做的修改也不会保存到数据库中。

3. 隔离性（isolation） 通常来说，一个事务所做的修改在最终提交以前，对其他事务
是不可见的。在前面的例子中，当执行完第三条语句、第四条语句 还未开始时，此时有另外一个账户汇总程序开始运行，则其看到的 支票账户的余额并没有被减去200美元。后面我们讨论隔离级别 （Isolation level）的时候，会发现为什么我们要说“通常来说”是不 可见的。

4. 持久性（durability） 一旦事务提交，则其所做的修改就会永久保存到数据库中。此
时即使系统崩溃，修改的数据也不会丢失。持久性是个有点模糊的 概念，因为实际上持久性也分很多不同的级别。有些持久性策略能 够提供非常强的安全保障，而有些则未必。而且不可能有能做到 100％的持久性保证的策略（如果数据库本身就能做到真正的持久 性，那么备份又怎么能增加持久性呢？）。在后面的一些章节中， 我们会继续讨论MySQL中持久性的真正含义。


#### 常见的四种隔离级别分别是？

在SQL标准中定义了四种隔离级别，
每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是 可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发， 系统的开销也更低。每种存储引擎实现的隔离级别不尽相同。

1. READ UNCOMMITTED（未提交读）在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对
其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。这个级别会导致很多问题，从性能上来说，READ UNCOMMITTED不会比其他的级别好太多，但却缺乏其他级别的很多好处，除非真的有非常必要的理由，在实际应用中一般很少使用。

2. READ COMMITTED（提交读）大多数数据库系统的默认隔离级别都是READCOMMITTED（但MySQL不是）。READ COMMITTED满足前面提到的隔离性的简单定
义：一个事务开始时，只能“看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。

3. REPEATABLE READ（可重复读）
REPEATABLE READ解决了脏读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个
事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom Row）。InnoDB和XtraDB存储引擎通过多版本并发控制（MVCC，MultiversionConcurrencyControl）解决了幻读的问题。本章稍后会做进一步的讨论。可重复读是MySQL的默认事务隔离级别。

4. SERIALIZABLE（可串行化） SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，
避免了前面说的幻读的问题。简单来说，SERIALIZABLE会在读取的 每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。 实际应用中也很少用到这个隔离级别，只有在非常需要确保数据的 一致性而且可以接受没有并发的情况下，才考虑采用该级别。
    

#### 死锁产生的原因和解决方法？

死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对。
方占用的资源，从而导致恶性循环的现象。当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。

越复杂的系统，比如InnoDB存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有效，否则死锁会导致出现非常慢的查询。还有一种解决方式，就是当查询的时间达到锁等待超时 的设定后放弃锁请求，这种方式通常来说不太好。InnoDB目前处理死 锁的方法是，将持有最少行级排他锁的事务进行回滚（这是相对比较简单的死锁回滚算法）。
锁的行为和顺序是和存储引擎相关的。以同样的顺序执行语句，有些存储引擎会产生死锁，有些则不会。死锁的产生有双重原因：有些是 因为真正的数据冲突，这种情况通常很难避免，但有些则完全是由于存储引擎的实现方式导致的。死锁发生以后，只有部分或者完全回滚其中一个事务，才能打破死
锁。对于事务型的系统，这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。


#### MySQL的索引实现？

当人们谈论索引的时候，如果没有特别指明类型，那多半说的是B-Tree索引，它使用B-Tree数据结构来存储数据。
B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。
B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行
全表扫描来获取需要的数据，取而代之的是从索引的根节点（图示并未 画出）开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引 擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找 到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的 上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。

