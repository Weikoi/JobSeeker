## OS基础
（参考《计算机操作系统》）

---
---
### OS概述

#### OS的特征有哪几个？

* 并发 Concurrennce：注意并发、并行的区别。
* 共享 Sharing：资源的占有方式。
* 虚拟 Virtual：将单台实体硬件抽象成多台。
* 异步 Asynchronism：进程的运行总是走走停停，以不可预知的速度向前推进。

并发和共享是OS最重要最基础的特征

---

#### OS实现的功能有哪些？

1. 资源管理

* 处理机管理（包括进程的控制、同步、通信、调度以及死锁的处理等）
* 存储器管理（包括内存的分配、保护、扩充等）
* 文件管理（磁盘管理、目录管理、读写管理）
* 设备管理（IO、缓冲、总线管理，设备分配）

2. 提供用户与硬件之间的接口
* 命令接口
* 程序接口（系统调用）
    
---

#### 实时系统需要保证的特征是？

实时性和可靠性

---

#### OS内核包括的主要内容？

* 时钟管理：提供标准的系统时间，提供时间片调度、时钟中断等功能。是OS最关键的设备。
* 中断机制：提高CPU的利用率。中断机制中只有小部分属于OS内核，即保护和恢复中断现场的信息、转移控制权给相关程序。
* 原语：原语是OS中最接近硬件底层的部分，运行具有原子性，不可被中断。
* 系统数据结构：如进程控制块、系统消息队列、缓冲区等
    
---

#### 何为中断？何为异常？何为系统调用？

* 广义上的中断包括外中断和内中断，外中断指硬件设备的处理请求：例如IO中断（键盘打字），时钟中断（处理机的时间片用完）等；
内中断指的就是异常；

* 异常指非法指令或者其他原因导致当前指令执行失败(如：内存出错、地址越界)后的处理请求；

* 系统调用指应用程序主动向操作系统发出的服务请求，即应用程序通过硬件中断从用户态进入系统的内核态，由系统内核接手完成一些特权指令后，再返回到用户态的过程。

---
---

### 进程管理

#### 何为进程？ 和程序的关系？

进程定义：进程是进程实体的运行过程，是OS进行资源分配和调度的独立单位。

那么什么是进程实体？因为多道程序的环境，要求程序并发并且独立地执行，那么就为它设计了一个专门的数据结构，称为PCB，即进程控制块。
OS可以利用PCB来查看进程的基本情况和运行的状态、控制和管理进程。PCB是进程存在的唯一标志，它常驻内存。

由PCB、相关的程序段、相关的数据段三部分构成的即进程实体。进程实体是静态的，而进程是动态的。

和程序的关系：

进程是程序的一次执行过程，是一个程序及其数据在处理机上顺序执行时所发生的活动。

---

#### 进程的状态和切换过程？
* 创建：分配进程标识号、PCB，然后是分配相应的系统资源如内存
* 就绪：处在就绪队列中
* 运行：获得CPU资源
* 阻塞：阻塞是进程的主动行为，但是唤醒是被动的
* 终止：正常结束或者发生异常

就绪到运行：获得CPU

运行到就绪：时间片用完，或者被高优先权的进程抢占CPU

运行到阻塞：进程被中断

阻塞到就绪：中断结束

需要注意的是运行过程中发生中断，进程被阻塞后进入阻塞状态，等中断结束，恢复的是就绪状态，而不是运行状态。

#### 进程通信的方式

高级通信方式：
 * 共享存储（共享一个存储区，但是同一时刻只有一方有读写的控制权）
 * 消息传递（通过格式化消息）
 * 管道通信（本质是共享一个文件，但是同时具有控制权，存在缓冲区）

低级通信方式：PV操作
 
 
#### 为什么要引入线程？进程和线程的异同点？
 
引入进程的目的是为了更好地使多道程序并发执行，以提高OS的资源利用效率和系统的吞吐量，增加并发程度；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，进一步提高系统的并发性能。

线程是轻量级的进程，是一个程序执行流的最小单元，它是进程中的一个实体，是系统独立调度和分配的基本单位，自己不拥有系统资源，与同进程中的其他线程一起共享进程的全部资源。

在引入线程的OS中，进程是除CPU外其它系统资源分配的单元，是拥有资源的基本单位，线程是处理机分配的单元，是独立调度的基本单位。

特点：

* 是独立调度的基本单位
* 除了运行过程中少量的必不可少的资源，线程不拥有系统资源
* 多线程之间也可以并发
* 同进程的线程之间切换开销极小（共享本进程的地址空间）
* 对其它进程是隐形的
* 同进程的线程间通信可以直接读/写进程数据段实现，非常高效。而不像进程需要PV操作。

---

#### OS中调度的层次？

1. 作业调度：决定哪些程序可以进入内存，建立进程获得处理机竞争的权力。
2. 中级调度：内存调度，把内存中暂时不会运行的挂起调至外存。
3. CPU调度：从就绪队列中按照某种策略选取进程，把处理机资源分配给它。

---

#### 处理机调度的基本准则？典型的调度算法？

* CPU利用率：调度的核心目标就是提高OS的CPU利用率
* 系统吞吐量：单位时间CPU的作业数量
* 周转时间：作业提交到完成的时间
* 等待时间：进程处于等待处理机状态的时间之和
* 响应时间：用户提交作业请求到首次响应的时间

典型的调度算法：

1. 先来先服务（FCFS）：

队列思想。算法简单，但是效率低下，对长作业也就是CPU繁忙型作业有利，但是对短作业也就是IO繁忙型不利。

2. 短作业优先（SJF）：

理论最佳算法。但是存在致命缺点，如果一直有短作业进入进程就绪队列，那么长作业将会一直处于饥饿状态。而且完全没有考虑作业的紧迫程度。
但是它的等待时间和周转时间都是理论最小。

3. 优先级调度：

根据优先级别调度，优先级别可以是静态的，也可以是动态的根据情况（诸如等待时间长度）而改变

4. 高响应比优先调度：

本质上属于优先级别调度算法，它是FCFS和SJF的平衡

其中响应比：

Rp = (等待时间 + 要求服务的时间) / 要求服务的时间

也就是说当等待时间足够长时，长作业也一定会被调度

5. 时间片轮转调度

优点是响应时间短，人机交互好，但是由于频繁进行进程切换，开销较大，效率下降。

6. 多级反馈队列调度

综合了时间片轮转和优先级调度的综合算法

为了提升吞吐量，缩短平均周转时间照顾短进程，也为了提高IO设备的利用率和缩短响应时间照顾IO型进程。

核心思想是：

> 设置多个就绪队列，第一队列优先级别最高，后面优先级别依次递减

> 优先级别越高的队列获得的时间片越小

> 新进程进入队列时，进入第一列队尾，按照FCFS调度，若没有在第一个时间片内处理完成，放入第二队列队尾...以此类推，最后一个队列采用时间片轮转算法。

> 只有当上一个队列为空时，才会执行下一个队列。如果执行期间，更高的队列有进入新的进程，将会被高优先权进程抢夺处理机

---

#### 进程同步有哪几种情况？

1. 同步：直接制约关系，简单理解就是上下游关系。
2. 互斥：简介之约关系，即争用临界资源。

遵循准则：
* 空闲让进
* 忙则等待
* 有限等待
* 让权等待：即没有获得临界资源的进程应当主动放弃处理机资源。

---

#### 临界区互斥基本算法

1. 单标志算法：
```
# p0进程
while(flag != 0){ }  # 进入区 # 意思是如果flag为1，将一直死循环，直到flag为0
critical section    # 临界区
flag == 1           # 退出区
remainder section   # 剩余区

# p1进程
while(flag != 1){ }  # 进入区 # 意思是如果flag为0，将一直死循环，直到flag为0
critical section    # 临界区
flag == 0           # 退出区
remainder section   # 剩余区
```
p0 进入临界区之后，flag一直为1，如果p1没有进过临界区（将flag置为0，让p0可以退出死循环），p0就再也无法进入临界区。

2. 双标志算法
```
# pi进程
while(flag[j]){ }  # 进入区 # 意思是如果flag为1，将一直死循环，直到flag为0
flag[i] == true     # 进入区
critical section    # 临界区
flag[i] == False    # 退出区
remainder section   # 剩余区

# pj进程
while(flag[i]){ }  # 进入区 # 意思是如果flag为1，将一直死循环，直到flag为0
flag[j] == true     # 进入区
critical section    # 临界区
flag[j] == False    # 退出区
remainder section   # 剩余区
```

不能交替访问，但是可以连续访问


