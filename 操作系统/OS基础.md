## OS基础
（参考《计算机操作系统》）

---
### OS概述

#### 现代OS的特征有哪几个？

* 并发 Concurrennce：注意并发、并行的区别。
* 共享 Sharing：资源的占有方式。
* 虚拟 Virtual：将单台实体硬件抽象成多台。
* 异步 Asynchronism：进程的运行总是走走停停，以不可预知的速度向前推进。

其中并发和共享是OS最重要最基础的特征。

---

#### OS实现的功能有哪些？

1. 资源管理

* 处理机管理（包括进程的控制、同步、通信、调度以及死锁的处理等）
* 存储器管理（包括内存的分配、保护、扩充等）
* 文件管理（磁盘管理、目录管理、读写管理等）
* 设备管理（IO、缓冲管理，设备分配）

2. 提供用户与硬件之间的接口

* 命令接口
* 程序接口（系统调用）
    
---

#### 实时系统需要保证的特征是？

实时性和可靠性

---

#### OS内核包括的主要内容？

* 时钟管理：提供标准的系统时间，提供时间片调度、时钟中断等功能。是OS最关键的设备。
* 中断机制：提高CPU的利用率。中断机制中只有小部分属于OS内核，即保护和恢复中断现场的信息、转移控制权给相关程序。
* 原语：原语是OS中最接近硬件底层的部分，运行具有原子性，不可被中断。
* 系统数据结构：如进程控制块、系统消息队列、缓冲区等
    
---

#### 何为中断？何为异常？何为系统调用？

* 广义上的中断包括外中断和内中断，外中断指硬件设备的处理请求：例如IO中断（键盘打字），时钟中断（处理机的时间片用完）等；
内中断指的就是异常；

* 异常指非法指令或者其他原因导致当前指令执行失败(如：内存出错、地址越界)后的处理请求；

* 系统调用指应用程序主动向操作系统发出的服务请求，即应用程序通过硬件中断从用户态进入系统的内核态，由系统内核接手完成一些特权指令后，再返回到用户态的过程。

---
---

### 进程管理

#### 何为进程？ 和程序的关系？

进程定义：进程是进程实体的运行过程，是OS进行资源分配和调度的独立单位。

那么什么是进程实体？因为多道程序的环境，要求程序并发并且独立地执行，那么就为它设计了一个专门的数据结构，称为PCB，即进程控制块。
OS可以利用PCB来查看进程的基本情况和运行的状态、控制和管理进程。PCB是进程存在的唯一标志，它常驻内存。

由PCB、相关的程序段、相关的数据段三部分构成的即进程实体。进程实体是静态的，而进程是动态的。

和程序的关系：

进程是程序的一次执行过程，是一个程序及其数据在处理机上顺序执行时所发生的活动。

---

#### 进程的状态和切换过程？
* 创建：分配进程标识号、PCB，然后分配相应的系统资源如内存
* 就绪：处在就绪队列中
* 运行：获得CPU资源
* 阻塞：阻塞是进程的主动行为，但是唤醒是被动的
* 终止：正常结束或者发生异常

就绪到运行：获得CPU

运行到就绪：时间片用完，或者被高优先权的进程抢占CPU

运行到阻塞：进程被中断

阻塞到就绪：中断结束

需要注意的是运行过程中发生中断，进程被阻塞后进入阻塞状态，等中断结束，恢复的是就绪状态，而不是运行状态。

---

#### 进程通信的方式

高级通信方式：
 * 共享存储（共享一个存储区，但是同一时刻只有一方有读写的控制权）
 * 消息传递（通过系统提供的格式化消息）
 * 管道通信（本质是共享一个pipe文件，但是同时具有控制权，存在缓冲区）

低级通信方式：PV操作
 
 ---
 
#### 为什么要引入线程？进程和线程的异同点？
 
引入进程的目的是为了更好地使多道程序并发执行，以提高OS的资源利用效率和系统的吞吐量，增加并发程度；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，进一步提高系统的并发性能。

线程是轻量级的进程，是一个程序执行流的最小单元，它是进程中的一个实体，是系统独立调度和分配的基本单位，自己不拥有系统资源，与同进程中的其他线程一起共享进程的全部资源。

在引入线程的OS中，进程是除CPU外其它系统资源分配的单元，是拥有资源的基本单位，线程是处理机分配的单元，是独立调度的基本单位。

特点：

* 是独立调度的基本单位
* 除了运行过程中少量的必不可少的资源，线程不拥有系统资源
* 多线程之间也可以并发
* 同进程的线程之间切换开销极小（共享本进程的地址空间）
* 对其它进程是隐形的
* 同进程的线程间通信可以直接读/写进程数据段实现，非常高效。而不像进程需要PV操作。

---

#### OS中调度的层次？

1. 作业调度：决定哪些程序可以进入内存，建立进程获得处理机竞争的权力。
2. 中级调度：内存调度，把内存中暂时不会运行的挂起调至外存。
3. CPU调度：从就绪队列中按照某种策略选取进程，把处理机资源分配给它。

---

#### 处理机调度的基本准则？典型的调度算法？

* CPU利用率：调度的核心目标就是提高OS的CPU利用率
* 系统吞吐量：单位时间CPU的作业数量
* 周转时间：作业提交到完成的时间
* 等待时间：进程处于等待处理机状态的时间之和
* 响应时间：用户提交作业请求到首次响应的时间

典型的调度算法：

1. 先来先服务（FCFS）：

队列思想。算法简单，但是效率低下，对长作业也就是CPU繁忙型作业有利，但是对短作业也就是IO繁忙型不利。

2. 短作业优先（SJF）：

理论最佳算法。但是存在致命缺点，如果一直有短作业进入进程就绪队列，那么长作业将会一直处于饥饿状态。而且完全没有考虑作业的紧迫程度。
但是它的等待时间和周转时间都是理论最小。

3. 优先级调度：

根据优先级别调度，优先级别可以是静态的，也可以是动态的根据情况（诸如等待时间长度）而改变

4. 高响应比优先调度：

本质上属于优先级调度算法，它是FCFS和SJF的平衡

其中响应比：

Rp = (等待时间 + 要求服务的时间) / 要求服务的时间

也就是说当等待时间足够长时，长作业也一定会被调度

5. 时间片轮转调度

优点是响应时间短，人机交互好，但是由于频繁进行进程切换，开销较大，效率下降。

6. 多级反馈队列调度

综合了时间片轮转和优先级调度的综合算法

为了提升吞吐量，缩短平均周转时间照顾短进程，也为了提高IO设备的利用率和缩短响应时间照顾IO型进程。

核心思想是：

> 设置多个就绪队列，第一队列优先级别最高，后面优先级别依次递减

> 优先级别越高的队列获得的时间片越小

> 新进程进入队列时，进入第一列队尾，按照FCFS调度，若没有在第一个时间片内处理完成，放入第二队列队尾...以此类推，最后一个队列采用时间片轮转算法。

> 只有当上一个队列为空时，才会执行下一个队列。如果执行期间，更高的队列有进入新的进程，将会被高优先权进程抢夺处理机

---

#### 进程同步有哪几种情况？

1. 同步：直接制约关系，简单理解就是上下游关系。
2. 互斥：间接制约关系，即争用临界资源。

遵循准则：
* 空闲让进
* 忙则等待
* 有限等待
* 让权等待：即没有获得临界资源的进程应当主动放弃处理机资源。

---

#### 信号量实现同步与互斥的原理？
    
p为申请资源，v为释放资源；
    
* 同步 
  
    因此为了实现同步，P2要在P1之后运行，那么P1释放资源执行V操作，P2申请资源执行P操作即可
    
    此时初始信号量为0

* 互斥

    每个进程都要用PV夹紧临界区，先P后V，临界区位于P和V之间
    
    此时初始信号量为1

---

#### 经典同步问题

1. 生产者-消费者问题？
    
生产者和消费者的关系是既同步也互斥，访问缓冲区是互斥的，生产之后才能消费表明又是同步关系

```
mutex = 1; //临界区访问信号量
empty = n; //缓冲区
producer(){
    while(1){
        produce an item;
        p(empty);   // 注意是先申请缓冲区
        p(mutex);   // 再申请临界区，否则会死锁
        add item into buffer;
        v(mutex);
        v(empty);
    }
}

Consumer(){
    while(1){
        p(full);
        p(mutex);
        remove item from buffer;
        v(mutex);
        v(full);
        consume the item;
    }
}
```
2. 读者-写者问题？

有这么几个特点：

1）同时允许多个读者读文件；

2）同时只允许一个写者写文件；
                  
3）写者完成操作之前，不允许其余读者和写者工作；

4）写者开始写之前，需要所有读者和写者退出；

```
int count = 0;
mutex = 1;  //读者互斥访问count信号量
rw = 1;     //读者写者互斥访问文件信号量

writer(){
    while(1){
        p(rw);
        writing;
        v(rw);
    }
}

reader(){
    while(1){
        p(mutex);
        if(count==0)
            p(rw);      // 读者开始读，不允许写者写
        count++;
        v(mutex)
        
        reading;
        
        p(mutex);
        count--;
        if(count==0)
            v(rw);  // 没有读者读，允许写者写
        v(mutex)；
    }
}
```

3. 哲学家进餐问题？
    
    五个哲学家共用五支筷子，如何吃饭？
    
    贪心算法的反向思路，不能贪心，否则会死锁。
    
    算法是只有哲学家左右手都有筷子时，才拿起筷子。否则等待。
    
    
    
4. 吸烟者问题？

    供应者提供资源组合（烟草、纸、胶水三者的两两组合），而每个吸烟者只有一种资源，只有同时获取三种资源才能吸烟。
    
    思路是为每一种资源组合提供一个信号量。

---

#### 关于死锁。定义？产生原因？如何预防？如何避免？如何解除？

* 死锁定义？

死锁是指多个进程因为争夺资源而陷入僵局，如果没有外力协助，所有的进程都将无法前进。


* 死锁产生的原因？

1）对不可剥夺系统资源的竞争

2）进程推进顺序非法（请求和释放资源顺序不当，或者是信号量使用不当）


* 死锁产生的必要条件？

1）互斥条件（资源不可共享）

2）不可剥夺条件（资源只能主动释放）

3）请求和保持条件（进程至少保持占有一种资源不放，请求新资源）

4）循环等待条件（资源分配图含圈，而且每种资源只有一种）


* 死锁如何预防？

1）破坏互斥条件（允许资源共享使用）

2）破坏不可剥夺条件（请求的资源不可满足时，进程必须主动放弃其它已经占有的资源）

3）破坏请求和保持条件（静态分配资源，在进程运行前，一次就把多有的资源分配给它）

4）破坏循环等待（按照顺序分配资源，给系统资源编号，只有先申请i,才能申请i+1）

* 死锁如何避免？

1）计算系统安全状态

系统在每次分配系统资源时，必须先计算资源分配的安全性，如果可能导致死锁，将不会进行分配，让进程等待

例如有某种系统资源12个

进程|需求|已分配
:--:|:--:|:--:
P1|10|5
P2|4|2
P3|9|2
此时剩余资源有三个，目前还是安全的，因为存在安全序列P2->P1->P3

但是此时如果先分配了两个资源给P3，系统便进入了不安全状态，因为剩下的一个资源无论给谁，都无法让进程完成运行

因此，在目前的状态下，如果P3提出申请两个资源，系统必须禁止；

2）银行家算法

按照某种规则分配系统资源：

即先满足最容易满足的进程，让他完成运行后释放被它占用的资源，这样系统资源就会越来越多。

按照Max需求矩阵和目前分配的Allocation矩阵计算Need矩阵，在Need矩阵中挑出目前可以满足的行，然后计算这些行中哪些被满足之后可以释放更多的资源（即Allocation中资源），作出决策，得到最终的安全序列。


* 死锁如何检测和解除？

根据进程占有和申请资源画出资源分配图，如果能消去所有的边，称为分配图可简化

死锁的条件即资源分配图不可完全简化

死锁的解除有以下几种方式：

1）资源剥夺

2）撤销进程

3）进程回退

4）重启系统

---
---
### 内存管理

#### 何为覆盖，何为交换？

* 覆盖

对于单道程序无法全部装入内存，分成固定区和覆盖区，经常活跃的程序段放入固定区，其余部分按照调用关系分段，即将访问的段放入覆盖区，其余的放在外存，等到需要调用时，再调入内存，替换覆盖区。

* 交换

对于多道程序运行，无法获得处理机资源的进程移出内存，称作换出；获得处理机争夺权的程序段调入内存，称为换入。

#### 内存连续分配管理方式有哪几种？

1. 单一连续分配

不分区，除了系统区外就是用户内存空间。

逻辑简单，无外部碎片，但是只能用于单用户单任务OS，有内部碎片，存储利用效率极低。

2. 固定分区分配

将用户内存空间分成若干个固定大小的区域，每个分区只能装入一道作业。

但是存在以下两个问题，第一个是程序段太大放不进一个分区，这时需要通过覆盖技术来处理；第二个是当程序段远小于一个分区空间时，仍然需要占用一个完成的空间，这样就造成了资源浪费

3. 动态分区分配

不预先划分内存分区，根据进程大小动态创建分区。 

初始分配效果很好，但是之后会出现大量外部碎片，需要通过compaction(紧凑)技术来解决，即过段时间OS需要对内存进行移动和整理，需要动态重定位寄存器的支持，而且非常费时


#### 进行进程装入时，如果有多个符合条件的内存块，该如何分配呢？

一般有以下几个算法：

* 首次适应算法：

按照地址递增顺序链接，分配地址顺位第一个满足要求的空闲分区。
（最简单，最快，效果最好）

* 最佳适应算法（最小分区优先）：

按照容量递增顺序链接，分配容量顺位第一个满足要求的分区，即最小的分区。
（性能通常最差，将会产生大量的外部碎片）

* 最坏适应算法（最大分区优先）：

按照容量递减顺序链接，分配容量顺位第一个满足要求的分区，即最大的分区。
（会造成分隔大内存块，OS将会没有大内存块可用，效果最差）

* 邻近适应算法：

类似于首次适应，但是查找开始的位置是上次查找结束的位置。（效果差于首次适应）









    


